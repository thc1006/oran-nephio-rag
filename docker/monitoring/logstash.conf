# O-RAN Ã— Nephio RAG ç³»çµ± Logstash é…ç½®
# æ—¥èªŒæ”¶é›†ã€è™•ç†å’Œè½‰ç™¼é…ç½®

input {
  # Docker å®¹å™¨æ—¥èªŒè¼¸å…¥
  beats {
    port => 5044
    type => "docker-logs"
  }
  
  # æª”æ¡ˆæ—¥èªŒè¼¸å…¥ (æ‡‰ç”¨ç¨‹å¼æ—¥èªŒ)
  file {
    path => "/data/oran-rag/logs/*.log"
    start_position => "beginning"
    type => "application-logs"
    codec => "json"
    tags => ["oran-rag", "application"]
  }
  
  # Syslog è¼¸å…¥
  syslog {
    port => 514
    type => "syslog"
    tags => ["system", "syslog"]
  }
  
  # HTTP è¼¸å…¥ (ç”¨æ–¼æ‡‰ç”¨ç¨‹å¼ç›´æŽ¥ç™¼é€æ—¥èªŒ)
  http {
    port => 8080
    type => "http-logs"
    codec => "json"
    tags => ["http-input"]
  }
  
  # Redis è¼¸å…¥ (ç”¨æ–¼é«˜å¯ç”¨æ—¥èªŒç·©è¡)
  redis {
    host => "redis-master"
    port => 6379
    password => "${REDIS_PASSWORD}"
    data_type => "list"
    key => "oran-rag-logs"
    type => "redis-logs"
    tags => ["redis-buffer"]
  }
}

filter {
  # åŸºæœ¬æ¬„ä½è™•ç†
  if [type] == "docker-logs" {
    # è§£æž Docker å®¹å™¨æ—¥èªŒ
    grok {
      match => { "message" => "%{TIMESTAMP_ISO8601:timestamp} %{LOGLEVEL:level} %{GREEDYDATA:log_message}" }
    }
    
    # è§£æžå®¹å™¨è³‡è¨Š
    if [docker][container][name] {
      mutate {
        add_field => { "container_name" => "%{[docker][container][name]}" }
        add_field => { "container_id" => "%{[docker][container][id]}" }
      }
    }
  }
  
  # æ‡‰ç”¨ç¨‹å¼æ—¥èªŒè™•ç†
  if [type] == "application-logs" {
    # è§£æž JSON æ ¼å¼æ—¥èªŒ
    if [message] =~ /^\{/ {
      json {
        source => "message"
        target => "app_log"
      }
      
      # æå–é—œéµæ¬„ä½
      if [app_log][timestamp] {
        date {
          match => [ "[app_log][timestamp]", "ISO8601" ]
          target => "@timestamp"
        }
      }
      
      if [app_log][level] {
        mutate {
          add_field => { "level" => "%{[app_log][level]}" }
        }
      }
      
      if [app_log][message] {
        mutate {
          add_field => { "log_message" => "%{[app_log][message]}" }
        }
      }
      
      # è™•ç†ç•°å¸¸è³‡è¨Š
      if [app_log][exception] {
        mutate {
          add_field => { "exception_type" => "%{[app_log][exception][type]}" }
          add_field => { "exception_message" => "%{[app_log][exception][message]}" }
          add_field => { "stack_trace" => "%{[app_log][exception][stack_trace]}" }
        }
        mutate {
          add_tag => [ "exception" ]
        }
      }
      
      # è™•ç† RAG ç‰¹å®šæ¬„ä½
      if [app_log][query_id] {
        mutate {
          add_field => { "query_id" => "%{[app_log][query_id]}" }
          add_field => { "query_text" => "%{[app_log][query_text]}" }
          add_field => { "response_time" => "%{[app_log][response_time]}" }
          add_field => { "documents_retrieved" => "%{[app_log][documents_retrieved]}" }
        }
        mutate {
          add_tag => [ "rag-query" ]
        }
      }
    } else {
      # è™•ç†ç´”æ–‡æœ¬æ—¥èªŒ
      grok {
        match => { 
          "message" => "%{TIMESTAMP_ISO8601:timestamp} \[%{LOGLEVEL:level}\] %{GREEDYDATA:log_message}" 
        }
      }
    }
  }
  
  # ç³»çµ±æ—¥èªŒè™•ç†
  if [type] == "syslog" {
    grok {
      match => { 
        "message" => "%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:host} %{WORD:program}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:log_message}" 
      }
    }
    
    date {
      match => [ "timestamp", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss" ]
    }
  }
  
  # å®‰å…¨ç›¸é—œæ—¥èªŒæ¨™è¨˜
  if [log_message] =~ /(error|Error|ERROR|fail|Fail|FAIL|exception|Exception|EXCEPTION)/ {
    mutate {
      add_tag => [ "error" ]
    }
  }
  
  if [log_message] =~ /(warn|Warn|WARN|warning|Warning|WARNING)/ {
    mutate {
      add_tag => [ "warning" ]
    }
  }
  
  if [log_message] =~ /(unauthorized|Unauthorized|UNAUTHORIZED|forbidden|Forbidden|FORBIDDEN|denied|Denied|DENIED)/ {
    mutate {
      add_tag => [ "security", "access-denied" ]
    }
  }
  
  if [log_message] =~ /(attack|Attack|ATTACK|malicious|Malicious|MALICIOUS|intrusion|Intrusion|INTRUSION)/ {
    mutate {
      add_tag => [ "security", "threat" ]
    }
  }
  
  # æ•ˆèƒ½ç›¸é—œæ¨™è¨˜
  if [response_time] {
    ruby {
      code => "
        response_time = event.get('response_time').to_f
        if response_time > 5.0
          event.set('performance_status', 'slow')
          event.tag('slow-response')
        elsif response_time > 2.0
          event.set('performance_status', 'warning')
          event.tag('warning-response')
        else
          event.set('performance_status', 'normal')
        end
      "
    }
  }
  
  # åœ°ç†ä½ç½®è³‡è¨Š (å¦‚æžœæœ‰ IP åœ°å€)
  if [client_ip] {
    geoip {
      source => "client_ip"
      target => "geoip"
    }
  }
  
  # ä½¿ç”¨è€…ä»£ç†è§£æž
  if [user_agent] {
    useragent {
      source => "user_agent"
      target => "ua"
    }
  }
  
  # ç§»é™¤ä¸éœ€è¦çš„æ¬„ä½
  mutate {
    remove_field => [ "host", "port", "path", "tags" ]
  }
  
  # æ­£è¦åŒ–æ™‚é–“æˆ³
  if ![timestamp] {
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  }
  
  # æ·»åŠ ç’°å¢ƒè³‡è¨Š
  mutate {
    add_field => { 
      "environment" => "${APP_ENV:development}"
      "service" => "oran-rag"
      "version" => "${VERSION:latest}"
    }
  }
}

output {
  # æ ¹æ“šç’°å¢ƒæ±ºå®šè¼¸å‡ºç›®æ¨™
  if "${APP_ENV}" == "production" {
    # ç”Ÿç”¢ç’°å¢ƒ: è¼¸å‡ºåˆ° Elasticsearch
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS}"]
      index => "oran-rag-logs-prod-%{+YYYY.MM.dd}"
      template_name => "oran-rag-template"
      template => "/etc/logstash/templates/oran-rag-template.json"
      template_overwrite => true
      
      # èº«ä»½é©—è­‰
      user => "${ELASTICSEARCH_USERNAME}"
      password => "${ELASTICSEARCH_PASSWORD}"
      
      # SSL è¨­å®š
      ssl => true
      ssl_certificate_verification => true
      cacert => "/etc/logstash/certs/ca.crt"
      
      # æ•ˆèƒ½è¨­å®š
      workers => 4
      flush_size => 1000
      idle_flush_time => 10
    }
    
    # éŒ¯èª¤æ—¥èªŒé¡å¤–ç™¼é€åˆ° Slack
    if "error" in [tags] or "exception" in [tags] {
      http {
        url => "${SLACK_WEBHOOK_URL}"
        http_method => "post"
        format => "json"
        mapping => {
          "text" => "ðŸš¨ O-RAN RAG Error Alert: %{log_message}"
          "channel" => "#oran-rag-alerts"
          "username" => "Logstash"
        }
      }
    }
    
    # å®‰å…¨å¨è„…æ—¥èªŒç™¼é€åˆ°å®‰å…¨ç³»çµ±
    if "security" in [tags] and "threat" in [tags] {
      http {
        url => "${SECURITY_WEBHOOK_URL}"
        http_method => "post"
        format => "json"
        headers => {
          "Authorization" => "Bearer ${SECURITY_API_TOKEN}"
        }
        mapping => {
          "alert_type" => "security_threat"
          "service" => "oran-rag"
          "message" => "%{log_message}"
          "timestamp" => "%{@timestamp}"
          "source_ip" => "%{client_ip}"
          "severity" => "high"
        }
      }
    }
    
  } else {
    # é–‹ç™¼ç’°å¢ƒ: è¼¸å‡ºåˆ° stdout å’Œæœ¬åœ°æª”æ¡ˆ
    stdout {
      codec => rubydebug
    }
    
    file {
      path => "/data/oran-rag/logs/processed/logstash-%{+YYYY.MM.dd}.log"
      codec => json_lines
    }
  }
  
  # æŒ‡æ¨™è¼¸å‡ºåˆ° Prometheus (é€šéŽ HTTP æŽ¨é€)
  if [response_time] {
    http {
      url => "http://pushgateway:9091/metrics/job/logstash/instance/oran-rag"
      http_method => "post"
      format => "form"
      mapping => {
        "rag_response_time_seconds" => "%{response_time}"
        "rag_query_total" => "1"
      }
    }
  }
  
  # å°‡è™•ç†éŽçš„æ—¥èªŒç™¼é€åˆ° Redis (ä½œç‚ºå…¶ä»–ç³»çµ±çš„ç·©è¡)
  redis {
    host => "redis-master"
    port => 6379
    password => "${REDIS_PASSWORD}"
    data_type => "list"
    key => "processed-logs"
    codec => json
  }
  
  # å„²å­˜åˆ°æª”æ¡ˆ (å‚™ä»½ç”¨é€”)
  file {
    path => "/data/oran-rag/logs/backup/logstash-backup-%{+YYYY.MM.dd}.log.gz"
    codec => json_lines
    gzip => true
  }
}

# é¡å¤–çš„ç®¡é“è¨­å®š (ç”¨æ–¼ç‰¹æ®Šè™•ç†)
pipeline {
  id => "security-pipeline"
  config.string => "
    input { 
      pipeline { 
        address => security 
      } 
    }
    filter {
      # å®‰å…¨æ—¥èªŒç‰¹æ®Šè™•ç†
      if [client_ip] {
        # æª¢æŸ¥æ˜¯å¦ç‚ºå·²çŸ¥æƒ¡æ„ IP
        translate {
          source => 'client_ip'
          target => 'threat_status'
          dictionary_path => '/etc/logstash/threat-ips.yml'
          fallback => 'clean'
        }
      }
      
      # ç•°å¸¸æ¨¡å¼æª¢æ¸¬
      if [log_message] =~ /(sql injection|SQL injection|xss|XSS|csrf|CSRF)/ {
        mutate {
          add_tag => [ 'attack-pattern' ]
          add_field => { 'attack_type' => 'web-attack' }
        }
      }
    }
    output { 
      elasticsearch {
        hosts => ['${ELASTICSEARCH_HOSTS}']
        index => 'oran-rag-security-%{+YYYY.MM.dd}'
        user => '${ELASTICSEARCH_USERNAME}'
        password => '${ELASTICSEARCH_PASSWORD}'
      }
    }
  "
}